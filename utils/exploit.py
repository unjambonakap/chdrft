import re
import chdrft.utils.misc as cmisc

# sample RopBuilderOld
# rop=misc.RopBuilderOld(buf_addr=0x1000)
# rop.add_mark('0')
# rop.add_simple_ref('0')
# rop.add_raw('abcdefghi')
# rop.add_mark('1')
# rop.add_simple_ref('1')
# print(rop.build())
#
# rop.clear()
# rop.add_struct('I#0#$0$^abcdefghi^#1#$1$I', 123, 4456)
# print(rop.build())


class RopBuilderOld:

  class RawElem:

    def __init__(self, data):

      if isinstance(data, str):
        data = data.encode('ascii')

      else:
        data = bytes(data)

      self.rop_builder = None
      self.data = data

    def get_length(self):
      return len(self.data)

    def build(self):
      return self.data

  class RefElem:

    def __init__(self, ref, mod):
      self.rop_builder = None
      self.ref = ref
      self.mod = mod

    def get_length(self):
      return self.rop_builder.ptr_size

    def build(self):
      lx = self.rop_builder.get_length_at_ref(self.ref)
      lx = self.mod(lx, self.rop_builder)
      return self.rop_builder.get_ptr_str(lx)

  def __init__(self, buf_addr=0, ptr_size=4):
    self.buf_addr = buf_addr
    self.ptr_size = ptr_size
    self.tb = []
    self.cur_len = 0
    self.marks = {}

    self.struct_ptr_str = '<'
    if ptr_size == 4:
      self.struct_ptr_str += 'I'
    elif ptr_size == 8:
      self.struct_ptr_str += 'Q'
    else:
      assert False, "Unsupported ptr_size"

  def clear(self):
    self.tb = []
    self.cur_len = 0
    self.marks = {}

  def get_ptr_str(self, val):
    return struct.pack(self.struct_ptr_str, val)

  def get_length_at_ref(self, ref):
    return self.marks[ref]

  def resize(self, n, c=b'a'):
    assert len(c) == 1
    diff = n - cur_len
    if diff > 0:
      self.add(RopBuilderOld.RawElem(c * diff))

  def add_elem(self, elem):
    self.tb.append(elem)
    elem.rop_builder = self
    self.cur_len += elem.get_length()

  def add_raw(self, s):
    self.add_elem(RopBuilderOld.RawElem(s))

  def add_mark(self, ref):
    self.marks[ref] = self.cur_len

  def add_simple_ref(self, ref):
    self.add_elem(RopBuilderOld.RefElem(ref, lambda x, rop: x + rop.buf_addr))

  def build(self):
    res = b''
    for elem in self.tb:
      res += elem.build()
    return res

  # <IQ#mark#$ref$^litteral^
  def add_struct(self, fmt, *args):
    args = list(args)

    assert isinstance(fmt, str)
    fmt.split
    order = '@'
    if fmt[0] in '@=<>!':
      order = fmt[0]
      fmt = fmt[1:]

    num = None
    cur = b''
    pos = 0
    modes = {}
    modes['#'] = lambda x: self.add_mark(x)
    modes['$'] = lambda x: self.add_simple_ref(x)
    modes['^'] = lambda x: self.add_raw(x)
    cur_mode = None
    mode_data = ''

    for i in fmt:
      v = ord(i) - ord('0')

      if i in modes:
        want_mode = i
        if cur_mode is None:
          cur_mode = want_mode
        else:
          assert want_mode == cur_mode, "Bad format"
          modes[cur_mode](mode_data)
          mode_data = ''
          cur_mode = None

      elif cur_mode is not None:
        mode_data += i

      else:
        if v >= 0 and v <= 9:
          if num is None:
            num = 0
          num = num * 10 + v
        else:
          if num is None:
            num = 1
          if i == b'x':
            cur += b'.{%d}' % num
          else:
            x = struct.pack('%c%d%c' % (order, num, i), *args[pos:pos + num])
            self.add_raw(x)
            pos += num
          num = None


#{fmt:var}
#{"string literal}
# {#mark}
#{$ref}

import re
import struct


class RopBuilder:
  STRUCT_RE = '(?=\w|\?)[^S]'

  class State:

    def __init__(self, args):
      self.args = args
      self.pos = 0

    def get_next(self, cnt=1):
      res = self.args[self.pos:self.pos + cnt]
      self.pos += cnt
      return res

    def get_arg(self, pos):
      print('GET ARG ', pos, self.args[pos])
      return self.args[pos]

  class Node:
    NODE_STRUCT = 0
    NODE_SPE = 1
    NODE_STRING = 2

    def __init__(self, typ):
      self.typ = typ
      self.off = None
      self.builder = None

    def get(self):
      assert False

    def len(self):
      return len(self.get())

    def set_off(self, off):
      self.off = off

  class StructNode(Node):

    def __init__(self, fmt, args):
      super().__init__(RopBuilder.Node.NODE_STRUCT)
      self.args = args
      self.fmt = fmt

    def get(self):
      return struct.pack(self.fmt, *self.args)

  class StringNode(Node):

    def __init__(self, str_align, arg_func):
      super().__init__(RopBuilder.Node.NODE_STRING)
      self.str_align = str_align
      self.arg_func = arg_func

    def len(self):
      tmp = len(self.arg_func(self))
      tmp = ((tmp + self.str_align - 1) // self.str_align) * self.str_align
      return tmp

    def get(self):
      target_len = self.len()
      res = self.arg_func(self)
      if not isinstance(res, bytes):
        res = str(res).encode()
      res += b'\x00' * (target_len - len(res))
      return res

  class SpeNode(Node):

    def __init__(self, get_func, len_func=None, ref_name=None):
      super().__init__(RopBuilder.Node.NODE_SPE)

      self.get_func = get_func
      self.len_func = len_func

      if ref_name:
        ref_name = str(ref_name)
      self.ref_name = ref_name

    def get(self):
      return self.get_func(self)

    def len(self):
      if not self.len_func:
        return super().len()
      return self.len_func(self)

    def set_off(self, off):
      super().set_off(off)
      if self.ref_name:
        print('SETTING ', self.ref_name, off)
        self.builder.kw[RopBuilder.ref_key(self.ref_name)] = off

  class AlignNode(Node):
    def __init__(self, align):
      super().__init__(RopBuilder.Node.NODE_SPE)
      self.align = align
    def get(self):
      return b'\x00' * self.len()

    def len(self):
      return (self.align - self.off) % self.align


  def __init__(self, start_off=0, ptr_size=8, **kw):
    avail_fmt = {4: 'I', 8: 'Q'}
    assert ptr_size in avail_fmt
    self.default_fmt = avail_fmt[ptr_size]

    self.kw = cmisc.Attributize(elem=kw.copy())
    self.tb = []
    self.start_off = start_off

  def update_kw(self, **kw):
    self.kw.update(kw)

  @staticmethod
  def ref_key(ref):
    return '_ref_%s' % ref

  def get_ref(self, ref):
    return self.kw[self.ref_key(ref)]

  def get_ref_off(self, ref):
    return self.kw[self.ref_key(ref)] - self.start_off


  def add_str(self, u):
    if isinstance(u, str):
      u = u.encode()
    self.tb.append(RopBuilder.SpeNode(lambda x, u=u: u))

  def add_spe(self, state, s):
    assert len(s)
    cur, nd = RopBuilder.find_closing(s)

    if cur[0] == '"':
      self.add_str(cur[1:])
    elif cur[0] == '#':
      self.tb.append(RopBuilder.SpeNode(lambda x: '', lambda x: 0, ref_name=cur[1:]))
    elif cur[0] == '~':
      self.tb.append(RopBuilder.AlignNode(int(cur[1:])))
    else:

      fmt_re = '((?P<fmt>{})|(?P<fmt_str>S(?P<str_align>\d)?)|)'.format(RopBuilder.STRUCT_RE)

      expr_re = '((?P<num_ref>\d+)|(?P<expr>\D.*))'
      final_re = '^{}:{}$'.format(fmt_re, expr_re)
      m = re.match(final_re, cur)
      assert m, 're=%s, have=%s'%(final_re, cur)

      if m.group('num_ref'):
        expr_arg = lambda x: state.get_arg(int(m.group('num_ref')))
      else:
        expr_arg = lambda x, content=m.group('expr'): eval(content, x.builder.kw)

      node = None
      if m.group('fmt_str'):
        str_align = int(m.group('str_align') or 1)
        node = RopBuilder.StringNode(str_align, expr_arg)

      else:
        fmt = m.group('fmt') or self.default_fmt
        get_func = lambda x, fmt=fmt, expr_arg=expr_arg: struct.pack(fmt, expr_arg(x))
        len_func = lambda x, fmt=fmt: len(struct.pack(fmt, 0))

        node = RopBuilder.SpeNode(get_func, len_func)
      self.tb.append(node)
    return nd

  def add_raw(self, state, s):
    m = re.search('^(\d*)?({})'.format(RopBuilder.STRUCT_RE), s)
    assert m, 'have=%s'%s

    cnt = 1
    if m.group(1):
      cnt = int(m.group(1))
    if m.group(2) == 's':
      cnt = min(cnt, 1)
    self.tb.append(RopBuilder.StructNode(m.group(0), state.get_next(cnt)))
    return m.end(0)

  def add(self, s, *args, **kwargs):
    self.update_kw(**kwargs)
    i = 0
    state = RopBuilder.State(args)

    while i < len(s):
      if s[i] == '{':
        i += self.add_spe(state, s[i + 1:]) + 1
      else:
        i += self.add_raw(state, s[i:])

  def find_closing(s):
    cnt = 1
    escape = 0
    i = 0
    s2 = ''

    while i < len(s):
      c = s[i]
      i += 1
      if escape:
        s2 += c
        escape = 0
        continue
      if c == '\\':
        escape = 1
      else:
        if c == '}':
          cnt -= 1
        elif c == '{':
          cnt += 1

        if cnt == 0:
          return s2, i
        s2 += c
    assert False

  def get(self, end_off=None):

    totlen = 0
    pass0_off=0
    for e in self.tb:
      e.builder = self
      e.set_off(pass0_off)
      pass0_off += e.len()

    off = self.start_off
    if end_off is not None:
      off = end_off - pass0_off


    for e in self.tb:
      e.set_off(off)
      off += e.len()

    res = b''
    for e in self.tb:
      tmp = e.get()
      if isinstance(tmp, str):
        tmp = tmp.encode()
      res += tmp

    return res


#x = RopBuilder()
#x.add('{S8:a+1}', a=12)
# x.add('QI{"jambon{}kappa}{?:2}{#abc}{b:_ref_abc+5}', 12, 13, 0)
# x.add('{H:tb[0]+tb[2]+_ref_abc}')
#x.update_kw(tb=(1, 4, 100))
#
#res = x.get()
# print(res)
# print(res[-1])
